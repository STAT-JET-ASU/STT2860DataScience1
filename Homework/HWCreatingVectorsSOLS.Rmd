---
title: "Homework: Creating & Exploring Vectors"
subtitle: "STT 2860 Intro to Data Mgmt & Visualization" 
author: "SOLUTIONS / Jill E. Thomley"
date: "`r format(Sys.time(), '%A, %B %d, %Y @ %I:%M %p')`"
output: 
  html_document: 
    theme: yeti
    highlight: textmate
    toc: true
    toc_depth: 4 
---

```{r globaloptions, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  comment = NA
)
```

***

**DOCUMENT NAME**: Please save your document using the name format `HWCreatingVectorsLastnameFirstname`.

***

### Problem 1: Using the `vector()` function

* Use the `vector()` function to create each indicated vector type.
* Choose a length between three and ten (inclusive) for each vector.
* Use the assignment operator `<-` to store each vector as an object.
* Print out each vector by typing the object name to call its contents. 
* Use the `typeof()` function on each vector to verify the vector type.
* Use the `length()` function on each vector to verify the vector length.

#### (a) `logical` 

```{r}
# create the vector
my_logical <- vector(mode = "logical", length = 10)
my_logical_alt <- vector("logical", 10)

# print the vector
my_logical
my_logical_alt

# type of vector
typeof(my_logical)
typeof(my_logical_alt)

# length of vector
length(my_logical)
length(my_logical_alt)

# are they the same?
my_logical == my_logical_alt           # compares each vector element for exact equality
all.equal(my_logical, my_logical_alt)  # compares the overall vectors for ‘near equality’
identical(my_logical, my_logical_alt)  # compares the overall vectors for exact equality
```

***

**NOTE:** Once you get comfortable working with a specific function, you can sometimes leave out the text identifying the parameter options (e.g., `mode =`) and just input the values, as long as they are in order and not ambiguous. Here, the `vector()` function has only two parameters, as we can see in the syntax: `vector(mode = "logical", length = 0)`.

***

#### (b) `integer` 

```{r}
# create the vector
my_integer <- vector(mode = "integer", length = 5)

# print the vector
my_integer

# type of vector
typeof(my_integer)

# length of vector
length(my_integer)

# what if we compare it to the logical?
my_logical == my_integer
all.equal(my_logical, my_integer)
identical(my_logical, my_integer)
```

***

**NOTE:** Notice the output from the `all.equal()` function when the two vectors are not the same. What is it telling you? 

***

#### (c) `double` 

```{r}
# create the vector
my_double <- vector(mode = "double", length = 7)

# print the vector
my_double

# type of vector
typeof(my_double)

# length of vector
length(my_double)
```

#### (d) `complex` 

```{r}
# create the vector
my_complex <- vector(mode = "complex", length = 7)

# print the vector
my_complex

# type of vector
typeof(my_complex)

# length of vector
length(my_complex)
```

#### (e) `character` 

```{r}
# create the vector
my_character <- vector(mode = "character", length = 3)

# print the vector
my_character

# type of vector
typeof(my_character)

# length of vector
length(my_character)
```

#### (f) `raw` 

```{r}
# create the vector
my_raw <- vector(mode = "raw", length = 9)

# print the vector
my_raw

# type of vector
typeof(my_raw)

# length of vector
length(my_raw)
```


### Problem 2: Using `:`, `c()`, `seq()`, and `rep()`

Use the `:`, `c()`, `seq()`, and/or `rep()` function to create a vector appropriate to each statement. Store each vector and print out the results. Use `class()` on each vector to examine some of its properties.

#### (a) sample space

The sample space of a random variable X is {0, 1, 2, ..., 10}.

```{r}
samplespace <- 0:10
samplespace
class(samplespace)
```

#### (b) test scores

Scores on a test can be 0 or any positive, even integer up to 100.

```{r}
testscores <- seq(from = 0, to = 100, by = 2)
testscores
class(testscores)

testscores_alt <- seq(0, 100, 2)
testscores_alt
class(testscores_alt)

identical(testscores, testscores_alt)
```

***

**NOTE:** All values in the vectors are integers, but they are not classed as integer vectors, because we used the `seq()` function. We could coerce (convert) them into integer class vectors using the `as.integer()` function on each vector.

***

#### (c) solution pH

A machine reads the pH of a solution to one decimal place of precision.
 
```{r}
pHscale <- seq(from = 0, to = 14, by = 0.1)
pHscale
class(pHscale)
```

#### (d) rock-paper-etc

A player in a particular game can choose rock, paper, scissors, lizard, or Spock.

```{r}
game <- c("rock", "paper", "scissors", "lizard", "Spock")
game
class(game)
```

#### (e) countdown clock

A clock counts down from 60 seconds to zero seconds in whole-second increments.

```{r}
clock <- 60:0
clock
class(clock)

clock_alt <- seq(from = 60, to = 0, by = -1)
clock_alt
class(clock_alt)

clock == clock_alt
all.equal(clock, clock_alt)
identical(clock, clock_alt)
```

***

**NOTE:** The two vectors are *nearly* equal, but they are not *exactly* equal. Notice the two different classes. Why did that happen? 

***

#### (f) song chorus

A particular song's chorus contains the following three separate phrases, sung once in order and then repeated.
    + I get knocked down
    + But I get up again
    + You're never gonna keep me down
    
```{r}
chorus <- rep(c("I get knocked down", "But I get up again", "You're never gonna keep me down"), times = 2)
chorus
class(chorus)
```

***

**NOTE:** This song chorus is from ["Tumthumping"](https://youtu.be/2H5uWRjFsGc?si=pSwTV7cRUh-wfglg) by British band Chumbawumba.

***

#### (g) blood types

In a group of 100 people, each person has one of four possible blood types: A, B, AB, or O. (Use the `rep` function.)
    + A = 40% of the people
    + B = 11% of the people
    + AB = 4% of the people
    + O = 45% of the people
    
```{r}
bloodtypes <- rep(c("A", "B", "AB", "O"), times = c(40, 11, 4, 45))
bloodtypes
class(bloodtypes)

# we can check our work
length(bloodtypes) # do we have 100 elements (people) in our vector?
table(bloodtypes)  # counts how many of each category/value appears
```


### Problem 3: winnings from *Introduction to R*

In the second chapter of DataCamp's *Introduction to R* course, you created and manipulated vectors representing winnings for one week in poker and roulette. In some cases you performed operations more than once using different methods, to learn how to be more compact/efficient. You will adapt some of that work here. Be as neat and efficient as you can in your coding.

#### (a) winnings vectors

A person plays poker and roulette on weekdays for two weeks. Winnings (in US dollars) are tabulated below. Negative values are, of course, actually losses. Create named vectors of winnings for each game where the names are the days of the week. 

| Day Number | Day of the Week | Poker Winnings | Roulette Winnings |
|:----------:|:---------------:|:--------------:|:-----------------:|
|      1     |       Mon       |       140      |        -25        | 
|      2     |       Tue       |       -50      |        -50        |
|      3     |       Wed       |        20      |        100        |
|      4     |       Thu       |      -120      |       -350        |
|      5     |       Fri       |       240      |        105        |
|      6     |       Mon       |       100      |          5        |
|      7     |       Tue       |       -30      |        -85        |
|      8     |       Wed       |       305      |        210        |
|      9     |       Thu       |       -90      |        175        |
|     10     |       Fri       |      1000      |       -105        |

```{r}
# days vector
dayofweek <- rep(c("Mon", "Tue", "Wed", "Thu", "Fri"), times = 2)

# poker winnings
poker <- c(140, -50, 20, -120, 240, 100, -30, 305, -90, 1000)
names(poker) <- dayofweek

# roulette winnings
rltte <- c(-25, -50, 100, -350, 105, 5, -85, 210, 175, -105)
names(rltte) <- dayofweek

# take a look!
poker
rltte
```

***

**NOTE:** Below is an alternative method for creating a named vector. When would you want to use each of these two methods?

***

```{r}
poker_alt <- c(
  Mon = 140,
  Tue = -50,
  Wed = 20,
  Thu = -120,
  Fri = 240,
  Mon = 100,
  Tue = -30,
  Wed = 305,
  Thu = -90,
  Fri = 1000
)
poker_alt

# are they identical results?
identical(poker, poker_alt)
```

#### (b) daily totals

Combine your vectors from (a) to create a vector that contains the total win/loss amount for each of the 10 days.

```{r}
total <- poker + rltte
names(total) <- dayofweek

# take a look!
total
```

#### (c) overall totals

Use your vectors from (a) to find (i) total poker winnings, (ii) total roulette winnings, and (iii) total overall winningss.

```{r}
poker_profit <- sum(poker)   # add up all vector entries
poker_profit

rltte_profit <- sum(rltte)   # add up all vector entries
rltte_profit

total_profit <- sum(total)   # add up all vector entries
total_profit
```

#### (d) winning days

On which days did the person make money playing poker? On which days did they make money playing roulette? What about each day overall? In each of the three cases, select only those days and print them out.

```{r}
poker_select <- poker > 0
poker[poker_select]

rltte_select <- rltte > 0
rltte[rltte_select]

total_select <- total > 0
total[total_select]

# simplified one-step method
poker[poker > 0]   # poker vector [where value is >]
rltte[rltte > 0]   # rltte vector [where value is >]
total[total > 0]   # total vector [where value is >]
```

#### (e) one weekday

Choose one weekday (Monday through Friday). Create a vector that contains only those two days from the poker winnings vector. Do the same for roulette winnings vector and your vector of daily totals from (b).

```{r}
# one method using the locations
# difficult for a larger vector 

poker_weds <- poker[c(3, 8)]
poker_weds

rltte_weds <- rltte[c(3, 8)]
rltte_weds

total_weds <- total[c(3, 8)]
rltte_weds

# alternative using vector names
# careful, we have repeat names
# bonus, easy to change the day
# you can just change top line

daychoice <- dayofweek == "Wed"
daychoice

poker_day <- poker[daychoice]   # returns only where daychoice is TRUE
poker_day

rltte_day <- rltte[daychoice]   # returns only where daychoice is TRUE
rltte_day

total_day <- total[daychoice]   # returns only where daychoice is TRUE
total_day

total_day_alt <- poker_day + rltte_day   # could also just add like (a)
total_day_alt
```


***
```{r}
sessionInfo()
```

